// Code generated by protoc-gen-go. DO NOT EDIT.
// source: core.proto

/*
Package photon is a generated protocol buffer package.

It is generated from these files:
	core.proto
	evaluator.proto
	features.proto
	models.proto
	runner.proto

It has these top-level messages:
	ValueInterface
	ListInt32
	ListInt64
	ListFloat32
	ListFloat64
	EmptyRequest
	EmptyResponse
	DataBlob
	EvaluationRequest
	EvaluationResponse
	FeatureSet
	FeatureSetField
	FindFeatureSetRequest
	CreateFeatureSetRequest
	CreateFeatureSetResponse
	DeleteFeatureSetRequest
	Model
	ModelVersion
	ModelFeature
	PrecomputedFeaturesSet
	FindModelRequest
	CreateModelRequest
	CreateModelResponse
	DeleteModelRequest
	ListVersionsRequest
	FindVersionRequest
	SetPrimaryVersionRequest
	CreateVersionRequest
	CreateVersionResponse
	DeleteVersionRequest
	RunnerEvaluateRequest
	RunnerEvaluateResponse
*/
package photon

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ValueInterface struct {
	// Types that are valid to be assigned to Value:
	//	*ValueInterface_ValueBoolean
	//	*ValueInterface_ValueInt32
	//	*ValueInterface_ListInt32
	//	*ValueInterface_ValueInt64
	//	*ValueInterface_ListInt64
	//	*ValueInterface_ValueFloat32
	//	*ValueInterface_ListFloat32
	//	*ValueInterface_ValueFloat64
	//	*ValueInterface_ListFloat64
	//	*ValueInterface_ValueString
	//	*ValueInterface_ValueBytes
	Value isValueInterface_Value `protobuf_oneof:"value"`
}

func (m *ValueInterface) Reset()                    { *m = ValueInterface{} }
func (m *ValueInterface) String() string            { return proto.CompactTextString(m) }
func (*ValueInterface) ProtoMessage()               {}
func (*ValueInterface) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isValueInterface_Value interface {
	isValueInterface_Value()
}

type ValueInterface_ValueBoolean struct {
	ValueBoolean bool `protobuf:"varint,1,opt,name=value_boolean,json=valueBoolean,oneof"`
}
type ValueInterface_ValueInt32 struct {
	ValueInt32 int32 `protobuf:"varint,2,opt,name=value_int32,json=valueInt32,oneof"`
}
type ValueInterface_ListInt32 struct {
	ListInt32 *ListInt32 `protobuf:"bytes,3,opt,name=list_int32,json=listInt32,oneof"`
}
type ValueInterface_ValueInt64 struct {
	ValueInt64 int64 `protobuf:"varint,4,opt,name=value_int64,json=valueInt64,oneof"`
}
type ValueInterface_ListInt64 struct {
	ListInt64 *ListInt64 `protobuf:"bytes,5,opt,name=list_int64,json=listInt64,oneof"`
}
type ValueInterface_ValueFloat32 struct {
	ValueFloat32 float32 `protobuf:"fixed32,6,opt,name=value_float32,json=valueFloat32,oneof"`
}
type ValueInterface_ListFloat32 struct {
	ListFloat32 *ListFloat32 `protobuf:"bytes,7,opt,name=list_float32,json=listFloat32,oneof"`
}
type ValueInterface_ValueFloat64 struct {
	ValueFloat64 float64 `protobuf:"fixed64,8,opt,name=value_float64,json=valueFloat64,oneof"`
}
type ValueInterface_ListFloat64 struct {
	ListFloat64 *ListFloat64 `protobuf:"bytes,9,opt,name=list_float64,json=listFloat64,oneof"`
}
type ValueInterface_ValueString struct {
	ValueString string `protobuf:"bytes,10,opt,name=value_string,json=valueString,oneof"`
}
type ValueInterface_ValueBytes struct {
	ValueBytes []byte `protobuf:"bytes,11,opt,name=value_bytes,json=valueBytes,proto3,oneof"`
}

func (*ValueInterface_ValueBoolean) isValueInterface_Value() {}
func (*ValueInterface_ValueInt32) isValueInterface_Value()   {}
func (*ValueInterface_ListInt32) isValueInterface_Value()    {}
func (*ValueInterface_ValueInt64) isValueInterface_Value()   {}
func (*ValueInterface_ListInt64) isValueInterface_Value()    {}
func (*ValueInterface_ValueFloat32) isValueInterface_Value() {}
func (*ValueInterface_ListFloat32) isValueInterface_Value()  {}
func (*ValueInterface_ValueFloat64) isValueInterface_Value() {}
func (*ValueInterface_ListFloat64) isValueInterface_Value()  {}
func (*ValueInterface_ValueString) isValueInterface_Value()  {}
func (*ValueInterface_ValueBytes) isValueInterface_Value()   {}

func (m *ValueInterface) GetValue() isValueInterface_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ValueInterface) GetValueBoolean() bool {
	if x, ok := m.GetValue().(*ValueInterface_ValueBoolean); ok {
		return x.ValueBoolean
	}
	return false
}

func (m *ValueInterface) GetValueInt32() int32 {
	if x, ok := m.GetValue().(*ValueInterface_ValueInt32); ok {
		return x.ValueInt32
	}
	return 0
}

func (m *ValueInterface) GetListInt32() *ListInt32 {
	if x, ok := m.GetValue().(*ValueInterface_ListInt32); ok {
		return x.ListInt32
	}
	return nil
}

func (m *ValueInterface) GetValueInt64() int64 {
	if x, ok := m.GetValue().(*ValueInterface_ValueInt64); ok {
		return x.ValueInt64
	}
	return 0
}

func (m *ValueInterface) GetListInt64() *ListInt64 {
	if x, ok := m.GetValue().(*ValueInterface_ListInt64); ok {
		return x.ListInt64
	}
	return nil
}

func (m *ValueInterface) GetValueFloat32() float32 {
	if x, ok := m.GetValue().(*ValueInterface_ValueFloat32); ok {
		return x.ValueFloat32
	}
	return 0
}

func (m *ValueInterface) GetListFloat32() *ListFloat32 {
	if x, ok := m.GetValue().(*ValueInterface_ListFloat32); ok {
		return x.ListFloat32
	}
	return nil
}

func (m *ValueInterface) GetValueFloat64() float64 {
	if x, ok := m.GetValue().(*ValueInterface_ValueFloat64); ok {
		return x.ValueFloat64
	}
	return 0
}

func (m *ValueInterface) GetListFloat64() *ListFloat64 {
	if x, ok := m.GetValue().(*ValueInterface_ListFloat64); ok {
		return x.ListFloat64
	}
	return nil
}

func (m *ValueInterface) GetValueString() string {
	if x, ok := m.GetValue().(*ValueInterface_ValueString); ok {
		return x.ValueString
	}
	return ""
}

func (m *ValueInterface) GetValueBytes() []byte {
	if x, ok := m.GetValue().(*ValueInterface_ValueBytes); ok {
		return x.ValueBytes
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ValueInterface) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ValueInterface_OneofMarshaler, _ValueInterface_OneofUnmarshaler, _ValueInterface_OneofSizer, []interface{}{
		(*ValueInterface_ValueBoolean)(nil),
		(*ValueInterface_ValueInt32)(nil),
		(*ValueInterface_ListInt32)(nil),
		(*ValueInterface_ValueInt64)(nil),
		(*ValueInterface_ListInt64)(nil),
		(*ValueInterface_ValueFloat32)(nil),
		(*ValueInterface_ListFloat32)(nil),
		(*ValueInterface_ValueFloat64)(nil),
		(*ValueInterface_ListFloat64)(nil),
		(*ValueInterface_ValueString)(nil),
		(*ValueInterface_ValueBytes)(nil),
	}
}

func _ValueInterface_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ValueInterface)
	// value
	switch x := m.Value.(type) {
	case *ValueInterface_ValueBoolean:
		t := uint64(0)
		if x.ValueBoolean {
			t = 1
		}
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *ValueInterface_ValueInt32:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ValueInt32))
	case *ValueInterface_ListInt32:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ListInt32); err != nil {
			return err
		}
	case *ValueInterface_ValueInt64:
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ValueInt64))
	case *ValueInterface_ListInt64:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ListInt64); err != nil {
			return err
		}
	case *ValueInterface_ValueFloat32:
		b.EncodeVarint(6<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(math.Float32bits(x.ValueFloat32)))
	case *ValueInterface_ListFloat32:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ListFloat32); err != nil {
			return err
		}
	case *ValueInterface_ValueFloat64:
		b.EncodeVarint(8<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.ValueFloat64))
	case *ValueInterface_ListFloat64:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ListFloat64); err != nil {
			return err
		}
	case *ValueInterface_ValueString:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.ValueString)
	case *ValueInterface_ValueBytes:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ValueBytes)
	case nil:
	default:
		return fmt.Errorf("ValueInterface.Value has unexpected type %T", x)
	}
	return nil
}

func _ValueInterface_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ValueInterface)
	switch tag {
	case 1: // value.value_boolean
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &ValueInterface_ValueBoolean{x != 0}
		return true, err
	case 2: // value.value_int32
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &ValueInterface_ValueInt32{int32(x)}
		return true, err
	case 3: // value.list_int32
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ListInt32)
		err := b.DecodeMessage(msg)
		m.Value = &ValueInterface_ListInt32{msg}
		return true, err
	case 4: // value.value_int64
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &ValueInterface_ValueInt64{int64(x)}
		return true, err
	case 5: // value.list_int64
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ListInt64)
		err := b.DecodeMessage(msg)
		m.Value = &ValueInterface_ListInt64{msg}
		return true, err
	case 6: // value.value_float32
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Value = &ValueInterface_ValueFloat32{math.Float32frombits(uint32(x))}
		return true, err
	case 7: // value.list_float32
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ListFloat32)
		err := b.DecodeMessage(msg)
		m.Value = &ValueInterface_ListFloat32{msg}
		return true, err
	case 8: // value.value_float64
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &ValueInterface_ValueFloat64{math.Float64frombits(x)}
		return true, err
	case 9: // value.list_float64
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ListFloat64)
		err := b.DecodeMessage(msg)
		m.Value = &ValueInterface_ListFloat64{msg}
		return true, err
	case 10: // value.value_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &ValueInterface_ValueString{x}
		return true, err
	case 11: // value.value_bytes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Value = &ValueInterface_ValueBytes{x}
		return true, err
	default:
		return false, nil
	}
}

func _ValueInterface_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ValueInterface)
	// value
	switch x := m.Value.(type) {
	case *ValueInterface_ValueBoolean:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *ValueInterface_ValueInt32:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ValueInt32))
	case *ValueInterface_ListInt32:
		s := proto.Size(x.ListInt32)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ValueInterface_ValueInt64:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ValueInt64))
	case *ValueInterface_ListInt64:
		s := proto.Size(x.ListInt64)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ValueInterface_ValueFloat32:
		n += proto.SizeVarint(6<<3 | proto.WireFixed32)
		n += 4
	case *ValueInterface_ListFloat32:
		s := proto.Size(x.ListFloat32)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ValueInterface_ValueFloat64:
		n += proto.SizeVarint(8<<3 | proto.WireFixed64)
		n += 8
	case *ValueInterface_ListFloat64:
		s := proto.Size(x.ListFloat64)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ValueInterface_ValueString:
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ValueString)))
		n += len(x.ValueString)
	case *ValueInterface_ValueBytes:
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ValueBytes)))
		n += len(x.ValueBytes)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListInt32 struct {
	Value []int32 `protobuf:"varint,1,rep,packed,name=value" json:"value,omitempty"`
}

func (m *ListInt32) Reset()                    { *m = ListInt32{} }
func (m *ListInt32) String() string            { return proto.CompactTextString(m) }
func (*ListInt32) ProtoMessage()               {}
func (*ListInt32) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ListInt32) GetValue() []int32 {
	if m != nil {
		return m.Value
	}
	return nil
}

type ListInt64 struct {
	Value []int64 `protobuf:"varint,1,rep,packed,name=value" json:"value,omitempty"`
}

func (m *ListInt64) Reset()                    { *m = ListInt64{} }
func (m *ListInt64) String() string            { return proto.CompactTextString(m) }
func (*ListInt64) ProtoMessage()               {}
func (*ListInt64) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListInt64) GetValue() []int64 {
	if m != nil {
		return m.Value
	}
	return nil
}

type ListFloat32 struct {
	Value []float32 `protobuf:"fixed32,1,rep,packed,name=value" json:"value,omitempty"`
}

func (m *ListFloat32) Reset()                    { *m = ListFloat32{} }
func (m *ListFloat32) String() string            { return proto.CompactTextString(m) }
func (*ListFloat32) ProtoMessage()               {}
func (*ListFloat32) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ListFloat32) GetValue() []float32 {
	if m != nil {
		return m.Value
	}
	return nil
}

type ListFloat64 struct {
	Value []float64 `protobuf:"fixed64,1,rep,packed,name=value" json:"value,omitempty"`
}

func (m *ListFloat64) Reset()                    { *m = ListFloat64{} }
func (m *ListFloat64) String() string            { return proto.CompactTextString(m) }
func (*ListFloat64) ProtoMessage()               {}
func (*ListFloat64) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ListFloat64) GetValue() []float64 {
	if m != nil {
		return m.Value
	}
	return nil
}

type EmptyRequest struct {
}

func (m *EmptyRequest) Reset()                    { *m = EmptyRequest{} }
func (m *EmptyRequest) String() string            { return proto.CompactTextString(m) }
func (*EmptyRequest) ProtoMessage()               {}
func (*EmptyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type EmptyResponse struct {
}

func (m *EmptyResponse) Reset()                    { *m = EmptyResponse{} }
func (m *EmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmptyResponse) ProtoMessage()               {}
func (*EmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type DataBlob struct {
	// Types that are valid to be assigned to Part:
	//	*DataBlob_Name
	//	*DataBlob_Data
	Part isDataBlob_Part `protobuf_oneof:"part"`
}

func (m *DataBlob) Reset()                    { *m = DataBlob{} }
func (m *DataBlob) String() string            { return proto.CompactTextString(m) }
func (*DataBlob) ProtoMessage()               {}
func (*DataBlob) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isDataBlob_Part interface {
	isDataBlob_Part()
}

type DataBlob_Name struct {
	Name string `protobuf:"bytes,1,opt,name=name,oneof"`
}
type DataBlob_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*DataBlob_Name) isDataBlob_Part() {}
func (*DataBlob_Data) isDataBlob_Part() {}

func (m *DataBlob) GetPart() isDataBlob_Part {
	if m != nil {
		return m.Part
	}
	return nil
}

func (m *DataBlob) GetName() string {
	if x, ok := m.GetPart().(*DataBlob_Name); ok {
		return x.Name
	}
	return ""
}

func (m *DataBlob) GetData() []byte {
	if x, ok := m.GetPart().(*DataBlob_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DataBlob) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DataBlob_OneofMarshaler, _DataBlob_OneofUnmarshaler, _DataBlob_OneofSizer, []interface{}{
		(*DataBlob_Name)(nil),
		(*DataBlob_Data)(nil),
	}
}

func _DataBlob_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DataBlob)
	// part
	switch x := m.Part.(type) {
	case *DataBlob_Name:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Name)
	case *DataBlob_Data:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Data)
	case nil:
	default:
		return fmt.Errorf("DataBlob.Part has unexpected type %T", x)
	}
	return nil
}

func _DataBlob_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DataBlob)
	switch tag {
	case 1: // part.name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Part = &DataBlob_Name{x}
		return true, err
	case 2: // part.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Part = &DataBlob_Data{x}
		return true, err
	default:
		return false, nil
	}
}

func _DataBlob_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DataBlob)
	// part
	switch x := m.Part.(type) {
	case *DataBlob_Name:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case *DataBlob_Data:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Data)))
		n += len(x.Data)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ValueInterface)(nil), "photon.ValueInterface")
	proto.RegisterType((*ListInt32)(nil), "photon.ListInt32")
	proto.RegisterType((*ListInt64)(nil), "photon.ListInt64")
	proto.RegisterType((*ListFloat32)(nil), "photon.ListFloat32")
	proto.RegisterType((*ListFloat64)(nil), "photon.ListFloat64")
	proto.RegisterType((*EmptyRequest)(nil), "photon.EmptyRequest")
	proto.RegisterType((*EmptyResponse)(nil), "photon.EmptyResponse")
	proto.RegisterType((*DataBlob)(nil), "photon.DataBlob")
}

func init() { proto.RegisterFile("core.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0xb1, 0x6f, 0x9c, 0x30,
	0x14, 0xc6, 0xf1, 0x71, 0x90, 0xe3, 0x41, 0x52, 0xd5, 0xcd, 0xe0, 0xd1, 0x21, 0xaa, 0xe4, 0xe9,
	0x06, 0xce, 0xb2, 0x3a, 0x75, 0x40, 0x6d, 0x45, 0xa5, 0x4e, 0x54, 0xea, 0x1a, 0x99, 0xd4, 0x69,
	0x91, 0x08, 0xa6, 0xe0, 0x44, 0xca, 0x7f, 0xde, 0xb1, 0xc2, 0xc0, 0x01, 0xd7, 0xcb, 0xf8, 0x7d,
	0xfa, 0xe9, 0xfb, 0xfc, 0x9e, 0x1f, 0xc0, 0xbd, 0x6e, 0xd5, 0xbe, 0x69, 0xb5, 0xd1, 0xd8, 0x6f,
	0x7e, 0x6b, 0xa3, 0xeb, 0xf8, 0xaf, 0x0b, 0x57, 0x3f, 0x64, 0xf5, 0xa4, 0xbe, 0xd6, 0x46, 0xb5,
	0x0f, 0xf2, 0x5e, 0xe1, 0xf7, 0x70, 0xf9, 0xdc, 0x3b, 0x77, 0x85, 0xd6, 0x95, 0x92, 0x35, 0x41,
	0x14, 0xb1, 0x5d, 0xe6, 0xe4, 0x91, 0xb5, 0xd3, 0xc1, 0xc5, 0x37, 0x10, 0x0e, 0x58, 0x59, 0x9b,
	0x43, 0x42, 0x36, 0x14, 0x31, 0x2f, 0x73, 0x72, 0x78, 0x1e, 0xd3, 0x0e, 0x09, 0x4e, 0x00, 0xaa,
	0xb2, 0x33, 0x23, 0xe1, 0x52, 0xc4, 0xc2, 0xe4, 0xed, 0x7e, 0x68, 0xde, 0x7f, 0x2b, 0x3b, 0x63,
	0xb1, 0xcc, 0xc9, 0x83, 0x6a, 0x12, 0xab, 0x58, 0xc1, 0xc9, 0x96, 0x22, 0xe6, 0x2e, 0x63, 0x05,
	0x5f, 0xc6, 0x0a, 0x4e, 0xbc, 0xb3, 0xb1, 0x82, 0x2f, 0x62, 0x05, 0x9f, 0x87, 0x7a, 0xa8, 0xb4,
	0xec, 0x5f, 0xe3, 0x53, 0xc4, 0x36, 0xc7, 0xa1, 0xbe, 0x0c, 0x2e, 0xfe, 0x00, 0x91, 0x8d, 0x9e,
	0xa8, 0x0b, 0x1b, 0xfe, 0x6e, 0x19, 0x3e, 0xa2, 0x99, 0x93, 0x87, 0xd5, 0x2c, 0x4f, 0x0a, 0x04,
	0x27, 0x3b, 0x8a, 0x18, 0x5a, 0x17, 0x08, 0xbe, 0x2e, 0x10, 0x9c, 0x04, 0xaf, 0x14, 0xd8, 0xf7,
	0xcf, 0x05, 0x82, 0xe3, 0x5b, 0x18, 0x92, 0xee, 0x3a, 0xd3, 0x96, 0xf5, 0x2f, 0x02, 0x14, 0xb1,
	0xa0, 0x87, 0xac, 0xfb, 0xdd, 0x9a, 0xf3, 0xf6, 0x8a, 0x17, 0xa3, 0x3a, 0x12, 0x52, 0xc4, 0xa2,
	0xe3, 0xf6, 0xd2, 0xde, 0x4b, 0x2f, 0xc0, 0xb3, 0x2a, 0xbe, 0x81, 0xe0, 0xf8, 0x07, 0xf8, 0x7a,
	0x74, 0x09, 0xa2, 0x2e, 0xf3, 0xf2, 0xff, 0x10, 0xc1, 0xd7, 0x88, 0x3b, 0x21, 0xb7, 0x10, 0x2e,
	0xb6, 0xb2, 0x86, 0x36, 0xe7, 0xa0, 0xd3, 0x24, 0x34, 0x41, 0x57, 0x10, 0x7d, 0x7e, 0x6c, 0xcc,
	0x4b, 0xae, 0xfe, 0x3c, 0xa9, 0xce, 0xc4, 0x6f, 0xe0, 0x72, 0xd4, 0x5d, 0xa3, 0xeb, 0x4e, 0xc5,
	0x1f, 0x61, 0xf7, 0x49, 0x1a, 0x99, 0x56, 0xba, 0xc0, 0xd7, 0xb0, 0xad, 0xe5, 0xa3, 0xb2, 0xb7,
	0xd9, 0x6f, 0xc1, 0xaa, 0xde, 0xfd, 0x29, 0x8d, 0xb4, 0xc7, 0xd8, 0xcf, 0x6d, 0x55, 0xea, 0xc3,
	0xb6, 0x91, 0xad, 0x29, 0x7c, 0x7b, 0xfa, 0x87, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x42, 0x67,
	0x8e, 0xf3, 0x08, 0x03, 0x00, 0x00,
}
